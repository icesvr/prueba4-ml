# -*- coding: utf-8 -*-
"""Reconocimiento_de_imagenes_Red_Neuronal_Convolucional_Multiclase.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17BCPxDV2y-nM4lN6f_I6iBmmHlY1E47h
"""

from google.colab import drive
drive.mount('/content/drive')

#Carga de librerias
from PIL import Image
import os
import numpy as np

# Ruta a la carpeta que contiene las imágenes
folder_path = '/content/drive/MyDrive/ML'

# Lista para almacenar las imágenes cargadas
image_list = []
#Lista para almacenar las etiquetas
y = []
# Recorre todos los archivos en la carpeta
for filename in os.listdir(folder_path):
    if 'fresa' in filename:
      y.append(0) #indice 0 fresa
    elif 'naranja' in filename: #indice 1 naranja
      y.append(1)
    elif 'pera' in filename: #indice 2 pera
      y.append(2)
    elif 'tomate' in filename: #indice 3 tomate
      y.append(3)
    elif 'platano' in filename: #indice 4 platano
      y.append(4)
    if filename.endswith(".jpg") or filename.endswith(".png"):
        img_path = os.path.join(folder_path, filename)
        img = Image.open(img_path).convert('RGB') #Convierte la imagen en RGB(3canales)
        img = img.resize((128, 128))  # Redimensiona la imagen
        img_array = np.array(img) / 128.0  # Normaliza los valores de píxeles
        image_list.append(img_array)



# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
#img = mpimg.imread('your_image.png')
import matplotlib.pyplot as plt
nImagenes = len(image_list)
filas = nImagenes // 4
fig, axes = plt.subplots(filas,4, figsize=(32,32))
for f in range(filas):
  for c in range(4):
    axes[f,c].imshow(image_list[f*c])

#axes[0,0].imshow(image_list_train[0])
#for i,ax in enumerate(image_list_train):
#    ax.imshow(image_list_train[i].flat)
#imgplot = plt.imshow(img)
#plt.show()

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(image_list, y, test_size=0.2, random_state=42, stratify=y)

y_test

y_train

#Carga de librerias
import tensorflow as tf
import keras
from keras import datasets, layers, models
from keras.models import Sequential
from keras.layers import Dense, Flatten
keras.utils.set_random_seed(812)
np.random.seed(812)
model = models.Sequential()
model.add(layers.Conv2D(64, (3,3), activation='relu', input_shape=(128, 128, 3)))
model.add(layers.MaxPooling2D((2,2)))
model.add(layers.Conv2D(64, (3,3), activation='relu'))
model.add(layers.MaxPooling2D((2,2)))

model.add(layers.Flatten())
model.add(layers.Dense(128, activation='relu'))
model.add(layers.Dense(5,activation='softmax'))

#Se compila el modelo
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])


for i, img in enumerate(X_train):
    print(f"Imagen {i} tiene forma: {np.array(img).shape}")

#Cambiamos la forma
X_train = np.array(X_train)
y_train = np.array(y_train)

#Verificamos el cambio
y_train

type(y_train)

y_train.shape

y_train = keras.utils.to_categorical(y_train, num_classes=5)

#Ajustamos("Entrenamos") el modelo al conjunto de datos
ajuste = %time model.fit(X_train,y_train,epochs=70,batch_size=16)
ajuste

# Commented out IPython magic to ensure Python compatibility.
# %time y_train

#Cambiamos el formato al conjunto de prueba
X_test = np.array(X_test)
y_test = np.array(y_test)

y_test = keras.utils.to_categorical(y_test, num_classes=5)

#Verificamos su forma
y_test

#Usamos el modelo para predecir con el conjunto de prueba
y_pred = model.predict(X_test) #Esto genera una salida predicha

#Revisamos el resultado
y_pred

#Redondeamos los resultados
y_pred=np.round(y_pred)
y_pred

type(y_pred)

y_test

type(y_test)

y_pred = np.argmax(y_pred, axis=1)
y_pred

y_test = np.argmax(y_test, axis=1)
y_test

import pandas as pd
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, mean_absolute_error, mean_squared_error, r2_score

# Accuracy
# Métricas de clasificación
conf_matrix = confusion_matrix(y_test, y_pred)
accuracy = accuracy_score(y_test, y_pred)

# Calculamos precision, recall y f1 para cada clase
precision = precision_score(y_test, y_pred, average=None)
precision_avg = precision_score(y_test, y_pred, average="macro")
recall = recall_score(y_test, y_pred, average=None)
recall_avg = recall_score(y_test, y_pred, average="macro")
f1 = f1_score(y_test, y_pred, average=None)
f1_avg = f1_score(y_test, y_pred, average="macro")
print("Exactitud:", accuracy)
print("Precisión por clase:", precision,'->', precision_avg)
print("Sensibilidad por clase:", recall,'->', recall_avg)
print("F1 Score por clase:", f1,'->', f1_avg)

y_test

from sklearn.metrics import ConfusionMatrixDisplay
cm = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.display_labels = ['fresa','naranja','pera','tomate','platano']
disp.plot()

y_test

y_pred

import matplotlib.pyplot as plt
img_array = (X_test[1] * 255).astype(np.uint8)  # Scale to 0-255 and convert to 8-bit integer
img = Image.fromarray(img_array)
plt.imshow(img)